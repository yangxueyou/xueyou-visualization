### HTML+CSS

这种方式通常用来呈现普通的 Web 网页，虽然也可以绘制简单的柱状图，饼图，折线图，但是基本不用，

- 很难看出数据与图形的对应关系，有很多换算也需要开发人员自己来做。这样一来，一旦图表或数据发生改动，就需要我们重新计算
- 浏览器的渲染引擎在工作时，要先解析 `HTML(SVG)`、`构建 DOM 树`、`CSS`，`RenderObject` 树和 `RenderLaye`r 树，然后用 HTML（或 SVG）绘图。当`图形发生变化`时，我们很可能要`重新执行`全部的工作，这样的`性能开销`是`非常大`的。
- 相比于 `HTML 和 CSS`，`Canvas2D` 和 `WebGL` 更适合去做可视化这一领域的绘图工作。它们的`绘图 API` 能够`直接操作绘图上下文`，一般不`涉及引擎`的其他部分，在`重绘图像`时，也`不会`发生`重新解析文档`和`构建结构`的过程，开销要小很多。


**下面是简易版构建过程**

HTML(SVG)  -->  DOM 树  --> CSS --> CSSOM -->  计算布局  --> RenderObject 树  -->  RenderLayer 树 --> 绘图上下文`（Canvas2D + WebGL 操作的是这块）`

    

### SVG

SVG 和传统的 `HTML+CSS 的绘图方式差别不大`。只不过，HTML 元素在`绘制矢量图形`方面的能力有些`不足`，而 SVG 恰好弥补了这方面的缺陷。

数据和视图的对应关系比较明确，并且绘制不规则图形也比 html + css 简单很多

缺点：在渲染引擎中，SVG 元素和 HTML 元素一样，在输出图形前都需要经过`引擎的解析`、`布局计算`和`渲染树生成`。而且，一个 SVG 元素`只表示一种基本图形`，如果展示的数据很复杂，生成图形的 SVG 元素就会很多。这样一来，`大量的 SVG` 元素不仅会`占用很多内存空间`，还会增加引擎、布局计算和渲染树生成的`开销`，`降低性能`，减慢渲染速度。这也就注定了 SVG `只适合`应用于元素较少的`简单可视化场景。`

### Canvas2D

这是浏览器提供的 Canvas API 中的其中一种上下文，

无论是使用 `HTML/CSS` 还是 `SVG`，它们都属于`声明式绘图系统`，也就是我们根据数据创建各种不同的图形元素（或者 CSS 规则），然后`利用浏览器渲染引擎`解析它们并渲染出来。

Canvas2D 是 `指令式的绘图系统`,它是浏览器提供的一种可以直接用代码在一块平面的“画布”上绘制图形的 API，使用它来绘图更像是传统的“编写代码”，简单来说就是调用绘图指令，然后引擎直接在页面上绘制图形。

总结来说，`Canvas` 能够直接操作绘图上下文，`不需要经过 HTML、CSS 解析、构建渲染树、布局等一系列操作`。因此单纯绘图的话，Canvas 比 HTML/CSS 和 SVG 要快得多。

Canvas 和 SVG 的使用也不是非此即彼的，它们可以结合使用。因为 SVG 作为一种图形格式，也可以作为 image 元素绘制到 Canvas 中。举个例子，我们可以先使用 SVG 生成某些图形，然后用 Canvas 来渲染。这样，我们就既可以享受 SVG 的便利性，又可以享受 Canvas 的高性能了。

### WebGL

这是浏览器提供的 Canvas API 中的另一种上下文，它是 OpenGL ES 规范在 Web 端的实现

WebGL 利用了 GPU 并行处理的特性，这让它在处理大量数据展现的时候，性能大大优于前 3 种绘图方式

- 三种情况下我们有必要直接操作更强大的 GPU 来实现绘图。
  - **要绘制的图形数量非常多**，多达数万个几何图形需要绘制，而且它们的位置和方向都在不停地变化
  - **对较大图像的细节做像素处理**，比如，实现物体的光影、流体效果和一些复杂的像素滤镜。
  - **绘制 3D 物体**，因为 WebGL 内置了对 3D 物体的投影、深度检测等特性，所以用它来渲染 3D 物体就不需要我们自己对坐标做底层的处理了
